\chapter{Testing}

\section{Overall Approach to Testing}

The overall approach used to testing was a combination of both automated and manual testing. Unit tests were written for the parsing algorithm and manual testing was done for integration testing. The testing should show that the project can take in some SQL from a user and subsequently parse and visualise it in a way to make it simpler for the user to understand SQL. 

The unit tests show that the parsing algorithm is working correctly and throwing the correct syntax errors with the entered SQL or not throwing any error if the SQL is following the syntax properly. Manual testing was used to test the entire system working together and making sure that the initial requirements are met. this involved more of the user interface elements working correctly and making sure that the user can use the system without any issues.

\section{Automated Testing}

The automated testing addresses the requirement of validating the entered SQL and making sure it follows the PostgreSQL documentation of statement syntax. The parsing algorithm was written to be testable by throwing an error if the SQL does not validate. The unit tests can then catch that error and check that the error message to the user is correct and the parser is throwing the correct error. 

The unit tests were written using a testing framework for JavaScript called Mocha\cite{mocha}. The testing suite includes tests that parse a small string that is passed through but also it can read files from the testData directory where there are SQL files. These SQL files are database dump files containing statements that make up an entire database. 

Testing a file makes sure that an entire database can be parsed and correctly find that no errors are present. Testing simple statements is an easy way to enter a single statement with a missing part of syntax to test if the error thrown contains a message complaining about that particular part of syntax not being included. The unit tests are also testing the behaviour if data is entered that is meant to break the system, which tests for the robustness of the parser.

\subsection{Unit Testing Test Table}

\begin{center}
	\captionof{table}{\label{fig:unitTestTable}Table showing examples of the unit tests that were written, all of the following tests reference the SQL validation requirement (FR-2).}
	\setlength\extrarowheight{2pt}
	\begin{tabularx}{\textwidth}{|c|X|X|X|c|}
		\hline
		\textbf{Test ID} & \textbf{Description} & \textbf{Input} & \textbf{Expected Result} & \textbf{Pass/Fail} \\
		\hline
		ATC-1 & The parser should throw syntax error. & Validate the statement: "CREATE TABLE" & Error should be thrown with the message "Missing Semicolon in statement". & Pass \\
		\hline
		ATC-2 & The parser should not throw a syntax error. & Validate the test.sql file in the testData folder & Validation should be complete without syntax errors being thrown. & Pass \\
		\hline
	\end{tabularx}
\end{center}

\section{Manual Testing}

Manual testing was done because the system is quite complex to test using a testing framework. This part of testing tests the entire system and follows the steps that the user might follow but also steps that could potentially break the system. The manual testing was done to make sure that the requirements have been met that are not to do with the parsing since that was covered by the unit tests. 

Parsing is involved in these tests however, what is being tested is that the system as a whole reacts correctly to the output of the parsing, and also that the output matches for the same case as the unit tests. This is done to test that the parsing works correctly when it is isolated in unit tests but also when it is part of a much larger system.

\subsection{Manual Testing Test Table}

\begin{center}
	\captionof{table}{\label{fig:manualTestTable}Test table listing the manual tests.}
	\setlength\extrarowheight{2pt}
	\begin{tabularx}{\textwidth}{|c|c|X|X|X|c|}
		\hline
		\textbf{Test ID} & \textbf{Reference} & \textbf{Description} & \textbf{Steps} & \textbf{Expected Result} & \textbf{Pass/Fail} \\
		\hline
		MTC-1 & FR-1.1 & Entering valid SQL into the text area. & Enter a valid SQL statement into the labelled text area. & The text area border should turn to a green colour and the "Visualise" button should become enabled. & Pass \\
		\hline
		MTC-2 & FR-1.1 & Entering invalid SQL into the text area & Enter an invalid SQL statement into the labelled text area. & Text area border colour should turn to a red colour and an alert should appear with the syntax error message. & Pass \\
		\hline
		MTC-3 & FR-1.2 & Entering an valid SQL file into the file picker. & Enter an valid SQL file into the file picker. & Text area border should turn to a green colour and the "Visualise" button should become enabled. & Pass \\
		\hline
		MTC-4 & FR-1.2 & Entering an invalid file into the file picker. & Enter an invalid SQL file into the file picker. & The file picker border should turn to a red colour and an alert should appear with a message that the filename is invalid. & Pass \\
		\hline
		MTC-5 & FR-3 & Visualising a test database from a file. & Upload the file test.sql into the file picker and press the "Visualise" button. & The test database should be visualised correctly with the foreign key arrows. & Pass \\
		\hline
		MTC-6 & FR-4 & Viewing the syntax highlighting. & Upload the file test.sql into the file picker and press the "Visualise" button, then press the "Syntax View" tab button. & Syntax highlighting of the test database should be displayed with correct colours, syntax and indentation. & Pass \\
		\hline
		MTC-7 & FR-5 & Using the filters in syntax view. & Upload the file test.sql into the file picker and press the "Visualise" button, then press the "Syntax View" tab button and press the "serial" checkbox . & All of the "serial" data types should be highlighted in a green colour. & Pass \\
		\hline
		MTC-8 & FR-6 & Viewing a database flaw. & Upload the file test1.sql into the file picker and press the "Visualise" button, then press the "Problem view" tab button and press the accordion button. & There should be an user interface element displaying the missing primary key constraint. & Pass \\
		\hline
		MTC-9 & FR-6 & View problems of a database with no flaws & Upload the file test1.sql into the file picker and press the "Visualise" button, then press the "Problem view" tab button and press the accordion button. & There should be a prompt for the user to inform them that there are no database flaws detected & Pass \\
		\hline
		MTC-10 & FR-7 & Viewing advice on how to fix the flaws identified & Upload the file test1.sql into the file picker and press the "Visualise" button, then press the "Problem view" tab button and press the accordion button. & There should be information on how to fix a missing primary key constraint as well as a URL to the official PostgreSQL documentation. & Pass \\
		\hline
	\end{tabularx}
\end{center}

\section{User Testing}

